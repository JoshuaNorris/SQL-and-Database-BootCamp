10 - Looking through the windom
20 - Conditional Statement
30 - Index Algorithm


ADVANCED SQL

-----------------------------

SELECT dept_no, COUNT(emp_no)
FROM dept_emp
GROUP BY dep_no;

group by has very specific syntax

every column not in tho group-by clause must apply a funcction

group by utilizes a split-combine-strategy

you take a gorup of data, split it, apply a function, combine the resluts

Updated order of operations

from --> where --> group by --> select --> order by

All fields not in the aggregate function have to be in the groupby clause

-----------------------------

the HAVING clause is how you filter against groups

updated order of operations
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER

-----------------------------

Select col1, SUM(col2)
from table
GROUP BY col1

UNION

SOLECT SUM(col2)
from table


UNION ALL is another command, this command won't remove duplicate records

SELECT NULL AS "prod_id", sum(ol.quantity)
FROM orderlines AS ol


grouping sets allows you to combine the outputs of multiple groupings

SELECT prod_id, sum(ol.quantity)
FROM orderlines as ol
GROUP BY
	GROUPING SETS (
	(),
	(prod_id)
	)
ORDER BY prod_id DESC;

-----------------------------

ROLLUP

Rollup creates grouping sets by all combinations of the fields it gets

-----------------------------

WINDOW FUNCTIONS

What if I want to show something by my row based on a group calculation

Window Functions create a new column based on Fnuctions performed on a subset or "window" of the data

window_function(arg1, arg2, ...) OVER (
	[PARTITION BY partition_expression]
	[ORDER BY sort_expression [ASC | DESC] NULLS {FIRST | LAST}]
)


partition by is used to apply the function against groups

when order by is used in tho window function it gives the progression

Framing

rows or range - range of rows as a frome
preceding rews before the current one
following rows after the current one
unbounded preceding or following - returns all before or after
current row

ORDER BY in over is changing the frame of the calculation



SELECT emp_no,
       salary,
       COUNT (salary) OVER (
            ORDER BY emp_no
       )
FROM "public"."salaries"

This is i cummulative sum
(starts with 17 then 23 then 30 then 43)

SELECT emp_no,
       salary,
       COUNT (salary) OVER (
            partition BY emp_no
       )
FROM "public"."salaries"

This finds the count for eoch emp_no
(17, 6, 7)


SELECT emp_no,
       salary,
       COUNT (salary) OVER (
            partition BY emp_no
            ORDER BY salary
       )
FROM "public"."salaries"

This creates a cummulative sum inside of each partition


SELECT emp_no,
       salary,
       COUNT (salary) OVER (
            partition BY emp_no
            ORDER BY salary
            RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
       )
FROM "public"."salaries"

This has the same output as the partition query

FIRST_VALUE

-----------------------------

CONDITIONALS

SELECT a,
	CASE WHEN a=1 THEN 'one'
	     WHEN a=2 THEN 'two'
	     ELSE 'other'
	END
from test;

each case wust return a single outcome

-----------------------------

NULL IF

NULLIF(0,0) -> NULL
NULLIF('ABC, DEF') -> ABC

if the left and right hand side rae equal it returns null

-----------------------------

VIEWS

What if we want to store the the results of a query?
Or what if we want to query the results of a query?

2 kinds of views
	Materialized
		Stores the data physically and periodically updates it when tables change
	Non-Materialized
		Quary gets re-run each time the view is called
		So we are storing a reference to the query

CREATE VIEW view_name AS 
SELECT *
FROM employees

Non materialied views take up very little space

CREATE OR REPLACE VIEW last_salary_change AS
SELECT  e.emp_no,
        MAX(s.from_date)
        
FROM salaries as s

join employees as e using(emp_no)
join dept_emp as de using(emp_no)
join departments as d using(dept_no)

group by e.emp_no
order by e.emp_no;

SELECT * FROM last_salary_change





































































SQL Deep Dive

SELECT * FROM "public"."titles"
where emp_no = 10006;


SELECT emp_no AS "Employee #", 
birth_date AS "Birthday" 
FROM "public"."employees";


SELECT emp_no, 
CONCAT(first_name, ' ', last_name) AS "Employee Name"
from "public"."employees"

Two kinds of functions
	Aggregate - takes all the data and produces one value
	Scalar - prduces data for each row

Examples of Aggregate functions
	AVG, COUNT, MIN, MAX, SUM

SELECT MAX(salary)
from "public"."salaries"


-- This is a SQL Comment
/*
* This is a multi-line comment
*/


SELECT COUNT(customerid)
from "public"."customers"
WHERE (state = 'OR' OR state = 'NY') AND gender = 'F';

SELECT count(customerid)
from "public"."customers"
WHERE not age = 55;

--------------

SELECT count(customerid)
from "public"."customers"
WHERE gender = 'F' and state = 'OR';

SELECT count(customerid)
from "public"."customers"
WHERE age > 44 and income >= 100000;

SELECT count(customerid)
from "public"."customers"
WHERE (age > 30 and age < 50) AND income < 50000;

SELECT AVG(income)
from "public"."customers"
WHERE age > 20 and age < 50;

Order of operations
	from -> where -> select

Operator precedence
	Parentheses -> Mult / Div -> Sub / Add -> Not -> And -> Or


---------------------------

SELECT firstname, income, age 
from customers
WHERE income > 50000 AND (age < 30 OR age >= 50)
and (country = 'Japan' OR country = 'Australia')

SELECT SUM(totalamount)
FROM public.orders
WHERE EXTRACT(MONTH FROM orderdate) = 6
  AND EXTRACT(YEAR FROM orderdate) = 2004
  AND totalamount > 100;


----------------------------

SELECT Avg(coalesce(age, 15))
from "Student";

Select coalesce(name, 'The first name has not been given'),
coalesce(lastName, 'The last name has not been given'), age
from "Student"

-----------------------------

SELECT address1, coalesce(address2, 'No 2nd Address')
FROM "public"."customers";

SELECT *
FROM "public"."customers"
WHERE address2 IS NOT null;

SELECT coalesce(lastName, 'Empty'), * 
from "public"."customers"
where age is null;

-----------------------------

SELECT firstname
from "public"."customers"
where (age between 30 and 50) and income < 50000

SELECT avg(income)
from "public"."customers"
where age between 20 and 50

-----------------------------


SELECT count(customerid)
from "public"."orders"
where customerid in (7888, 1082, 12808, 9623)

SELECT count(id)
from "public"."city"
where district in ('Zuid-Holland', 'Noord-Brabant', 'Utrecht')


-----------------------------

ILIKE is case insensitive

SELECT first_name, EXTRACT (YEAR FROM AGE(birth_date)) as "age"
FROM "public"."employees"
where first_name LIKE 'M%';

SELECT count(emp_no)
FROM "public"."employees"
where first_name LIKE 'A%r';

SELECT count(customerid)
from "public"."customers"
where zip::text LIKE '%2%';

SELECT count(customerid)
from "public"."customers"
where zip::text LIKE '2_1%';

SELECT COALESCE(state, 'No state')
from "public"."customers"
where phone::text LIKE '302%';

-----------------------------

Dates are hard because of timezones

UTC - Universal Coordinate Time (standard for time)


SET TIME ZONE 'UTC'

Postgres automatically stores time in utc

ISO8601
YYYY-MM-DDTHH:MM:SS


CREAT TABLE timezones (
	ts 	TIMESTAMP WITHOUT TIME ZONE,
	ts 	TIMESTAMP WITH TIME ZONE,
)

SELECT NOW()::date;
SELECT CURRENT_DATE;

SELECT TO_CHAR( CURRENT_DATE, 'dd/mm/yyyy');

DATE_TRUNC('year', date '1992/11/13'); -> 1992

SELECT emp_no, first_name, last_name,
EXTRACT(YEAR FROM AGE(CURRENT_TIMESTAMP, birth_date)) AS age
FROM "public"."employees"
WHERE EXTRACT(YEAR FROM AGE(birth_date)) > 60;


SELECT Count(emp_no)
FROM "public"."employees"
WHERE EXTRACT(MONTH FROM AGE(hire_date)) = '2';

SELECT Count(emp_no)
FROM "public"."employees"
WHERE EXTRACT(MONTH FROM AGE(birth_date)) = '11';

SELECT Max(EXTRACT(YEAR FROM AGE(birth_date)))
FROM "public"."employees"

SELECT COUNT(orderid)
from "public"."orders"
where EXTRACT(month FROM orderdate) = '1' and EXTRACT(year FROM orderdate) = '2004';

-----------------------------

if you use the following syntax -> DISTINCT salary, from_date

this will return all of the columns with a  distinct pairing of those two things

SELECT distinct title
FROM "public"."titles"

SELECT DISTINCT lifeexpectancy
from "public"."country"
where lifeexpectancy is not null

-----------------------------

SELECT * FORM customers
ORDEF BY name DESC

SELECT * FORM customers
ORDER BY name, lastName DESC

ORDER BY naturally does ASC, in the query above the name is 
ASC and lastName DESC

SELECT * FORM customers
ORDER BY LENGTH(name)

SELECT first_name, last_name
FROM "public"."employees"
order by first_name asc, last_name desc

SELECT first_name, last_name, EXTRACT(YEAR FROM AGE(birth_date)) as age
FROM "public"."employees"
order by EXTRACT(YEAR FROM AGE(birth_date))

SELECT first_name, last_name, hire_date
FROM "public"."employees"
WHERE first_name like 'K%'
order by hire_date;

-----------------------------

MULTI-TABLE SELECT


SELECT a.emp_no,
       CONCAT(a.first_name, a.last_name) as "name",
       b.salary
FROM "public"."employees" as a, "public"."salaries" as b
WHERE a.emp_no = b.emp_no;

Joins from a primary key to a foreign key is the most commen approach



INNER JOIN

these find the intersection of two datasets... where there is overlap

SELECT a.emp_no, b.salary
FROM employees as a, salaries as b
WHERE a.emp_no = b.emp_no;

SELECT a.emp_no, b.salary
FROM employees as a
INNER JOIN salaries as b on b.emp_no = a.emp_no;

These two statements are the same ^^^

the results of a join always come back unsorted so you always need to add an "order by"

SELECT a.emp_no, b.salary
FROM employees as a
INNER JOIN salaries as b on b.emp_no = a.emp_no
ORDER BY a.emp_no;


SELECT a.emp_no,
       CONCAT(a.first_name, ' ', a.last_name) as "name",
       b.salary,
       c.title,
       c.from_date AS "promoted on"
FROM "public"."employees" as a
INNER JOIN "public"."salaries" AS b on a.emp_no = b.emp_no
INNER JOIN "public"."titles" as c ON c.emp_no = a.emp_no 
    AND c.from_date = (b.from_date + interval '2 days')
order by a.emp_no;


SELECT a.emp_no,
       CONCAT(a.first_name, ' ', a.last_name) as "name",
       b.salary,
       c.title,
       c.from_date AS "promoted on"
FROM "public"."employees" as a
INNER JOIN "public"."salaries" AS b on a.emp_no = b.emp_no
INNER JOIN "public"."titles" as c ON c.emp_no = a.emp_no 
    AND (
    b.from_date = c.from_date
    OR c.from_date = (b.from_date + interval '2 days')
    )
order by a.emp_no;


-----------------------------

SELF JOIN

This happens when a table has a foreign key that references its primary key


SELECT a.id, b.name,
FROM employees as a
INNER JOIN employees AS b 
ON a.supervisorid = b.id
order by a.emp_no;

-----------------------------

OUTER JOIN

What if I want the values from one of the tables that doesn't match?


SELECT emp.emp_no
FROM employees AS emp
LEFT JOIN dept_manager AS dep ON emp.emp_no = dep.emp_no
WHERE dep.emp_no IS NULL


-----------------------------

LESS COMMON JOINS

CROSS JOIN
	creates a combination of every row with every other row

	SELECT * FROM "cartesianA"
	CROSS JOIN "cartesianB"

FULL OUTER JOIN
	returns all results from both sets regardless on if they match or not

	
-----------------------------


SELECT e.emp_no, e.first_name, de.dept_no
FROM employees AS e
INNER JOIN dept_emp AS de USING(emp_no)

this works for the standard case of simple joins oof just a pribary key -> foreign key relationship





















































Databases + SQL Fundamentals

SELECT id, firstName
FROM Student;

SELECT *
FROM Student;


Declarative Language is about what will happen
Imperative Language says how it will happen

Heirarchical Database Model
	data is organized in a tree
	this has one-to-many relationship
		this means each parent can have many children,but only one porent

network model
	each child can have multiple parents
	many-to-many relationshups

Relational Model
	using tables instead of parent/child


Codd's 12 rules af Relational Databaso


Tables
	each table has a name
	degree - is the collection of all the columns
	tuple - is a row of data
	cardinality - the collection of rows

Primary and Foreign Keys
	The primary key is teh unique identifier of that data in the table
	the foreign key is a connection to a unique identifier in another table

OLTP vs. OLAP
	OLTP - day to day transaction processes
	OLAP - taking the OLTP and doing analytical processing on that data









History and Story of data

	5 types of databases
		Relational Model Database
		Document Model Database
		Key Value Database
		Graph Model Database
		Wide Columnar Model Database

