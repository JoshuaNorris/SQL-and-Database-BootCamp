10 - Looking through the windom
20 - Conditional Statement
30 - Index Algorithm


ADVANCED SQL

-----------------------------

SELECT dept_no, COUNT(emp_no)
FROM dept_emp
GROUP BY dep_no;

group by has very specific syntax

every column not in tho group-by clause must apply a funcction

group by utilizes a split-combine-strategy

you take a gorup of data, split it, apply a function, combine the resluts

Updated order of operations

from --> where --> group by --> select --> order by

All fields not in the aggregate function have to be in the groupby clause

-----------------------------

the HAVING clause is how you filter against groups

updated order of operations
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER

-----------------------------

Select col1, SUM(col2)
from table
GROUP BY col1

UNION

SOLECT SUM(col2)
from table


UNION ALL is another command, this command won't remove duplicate records

SELECT NULL AS "prod_id", sum(ol.quantity)
FROM orderlines AS ol


grouping sets allows you to combine the outputs of multiple groupings

SELECT prod_id, sum(ol.quantity)
FROM orderlines as ol
GROUP BY
	GROUPING SETS (
	(),
	(prod_id)
	)
ORDER BY prod_id DESC;

-----------------------------

ROLLUP

Rollup creates grouping sets by all combinations of the fields it gets

-----------------------------

WINDOW FUNCTIONS

What if I want to show something by my row based on a group calculation

Window Functions create a new column based on Fnuctions performed on a subset or "window" of the data

window_function(arg1, arg2, ...) OVER (
	[PARTITION BY partition_expression]
	[ORDER BY sort_expression [ASC | DESC] NULLS {FIRST | LAST}]
)


partition by is used to apply the function against groups

when order by is used in tho window function it gives the progression

Framing

rows or range - range of rows as a frome
preceding rews before the current one
following rows after the current one
unbounded preceding or following - returns all before or after
current row

ORDER BY in over is changing the frame of the calculation



SELECT emp_no,
       salary,
       COUNT (salary) OVER (
            ORDER BY emp_no
       )
FROM "public"."salaries"

This is i cummulative sum
(starts with 17 then 23 then 30 then 43)

SELECT emp_no,
       salary,
       COUNT (salary) OVER (
            partition BY emp_no
       )
FROM "public"."salaries"

This finds the count for eoch emp_no
(17, 6, 7)


SELECT emp_no,
       salary,
       COUNT (salary) OVER (
            partition BY emp_no
            ORDER BY salary
       )
FROM "public"."salaries"

This creates a cummulative sum inside of each partition


SELECT emp_no,
       salary,
       COUNT (salary) OVER (
            partition BY emp_no
            ORDER BY salary
            RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
       )
FROM "public"."salaries"

This has the same output as the partition query

FIRST_VALUE

-----------------------------

CONDITIONALS

SELECT a,
	CASE WHEN a=1 THEN 'one'
	     WHEN a=2 THEN 'two'
	     ELSE 'other'
	END
from test;

each case wust return a single outcome

-----------------------------

NULL IF

NULLIF(0,0) -> NULL
NULLIF('ABC, DEF') -> ABC

if the left and right hand side rae equal it returns null

-----------------------------

VIEWS

What if we want to store the the results of a query?
Or what if we want to query the results of a query?

2 kinds of views
	Materialized
		Stores the data physically and periodically updates it when tables change
	Non-Materialized
		Quary gets re-run each time the view is called
		So we are storing a reference to the query

CREATE VIEW view_name AS 
SELECT *
FROM employees

Non materialied views take up very little space

CREATE OR REPLACE VIEW last_salary_change AS
SELECT  e.emp_no,
        MAX(s.from_date)
        
FROM salaries as s

join employees as e using(emp_no)
join dept_emp as de using(emp_no)
join departments as d using(dept_no)

group by e.emp_no
order by e.emp_no;

SELECT * FROM last_salary_change

-----------------------------

INDEXES

An index is a construct to improve querying performance
Or a pointer to data in a table
	almost like a toble of contents

Indexes speed up lookups, but slow down data insertion and updates

Types of Indexes
	Single-Column
	Multi-Column
	Unique - There can be no two of the same values in that index
	Partial
	Implicit Indexes

CREATE <type> INDEX <name>
on <table> (col1, col2, etc);

DROP INDEX <name>

When to index
	foreign keys
	primary keys and unique columns
	on columns that end up in the order by/where clause often

When not to index
	don't add an index to add an index
	don't use indexes on small tables
	don't use on tables that are updated frequently
	don't use an columns that con contain null values
	don't use on calumns that have large values

Single Columns indexes
	used on the most frequently used coulumn in a query
	this is helpful when you are trying to retrieve data that satisfies one condition

Multi-Columns indexes
	used on the most frequently used columns in a query
	this is helpful when you are trying to retrieve data that satisfies multiple conditions

Unique indexes
	this is used for speed and integrity

partiol indexes
	these are over a sebset of a table

implicit indexes
	these are automatically created on databases on
		primary and unique keys



explain analyze
SELECT "name", district, countrycode from city
where countrycode in ('TUN', 'BE', 'NL')


CREATE INDEX idx_countrycode
ON city (countrycode)

Index Algorithms

Postgress' algorithms
	Btree
		This is the default... it is best when used with camparisons (<, >, in, is null, etc.)
	Hash
		This can only handle equality checks
	Gin (Generalized Inverted Index)
		Best used when multiple values are stored in a single field
			For instance array types
	Gist (Generalized Search Tree)
		Useful in indexing Geometric data and Full-Text Search


CREATE <type> INDEX <name>
on <table> USING <method> (col1, col2, etc);


-----------------------------

SUBQUERIES (Inner Query or Inner Select)

This is most often found in the WHERE clause

SELECT *
FROM <table>
WHERE <col> <condition> (
	SELECT <col>, <col>, ...
	FROM <table>
	[WHERE | GROUP BY | ORDER BY...]
)

You can also use it in the SELECT, FROM, AND HAVING

SELECT (
	SELECT <col>, <col>, ...
	FROM <table>
	[WHERE | GROUP BY | ORDER BY...]
) -- This must return a single record
FROM <table>
WHERE <col> <condition> 

SELECT *
FROM (
	SELECT <col>, <col>, ...
	FROM <table>
	[WHERE | GROUP BY | ORDER BY...]
) as <name>
WHERE <col> <condition>


SELECT *
FROM <table AS <name>
GROUP BY <col>
HAVING (
	SELECT <col>, <col>, ...
	FROM <table>
	[WHERE | GROUP BY | ORDER BY...]
) > X
This also must return a single record

Subqueries vs. Join

Subqueries could stand alone 

Subqueries can return a single row or a row set, joins only do row set

subqueries results are immediotely used

Joins are able to be referenced at other parts of the query

If you can use a join, then you should use a join because they are more performant

A subquery must be used in parentheses

They must be placed on the right side of the comparison operator

A subquery cannot manipulate their results internally (order by is ignored)

Use Single-row Operators with single-row subqueries

Subqueries that return null may not return results

Types of Subqueries
	Single Row
		returns 0 or one row
	Multiple Row
		tends to use "IN"
	Multiple Column
		THis can be used to join on
	Correlated
		References one or more columns in tho outer statement
		these can be very slow
	nested

Subquery Operators

	WHERE EXISTS

	WHERE IN

	where category = any

























































SQL Deep Dive

SELECT * FROM "public"."titles"
where emp_no = 10006;


SELECT emp_no AS "Employee #", 
birth_date AS "Birthday" 
FROM "public"."employees";


SELECT emp_no, 
CONCAT(first_name, ' ', last_name) AS "Employee Name"
from "public"."employees"

Two kinds of functions
	Aggregate - takes all the data and produces one value
	Scalar - prduces data for each row

Examples of Aggregate functions
	AVG, COUNT, MIN, MAX, SUM

SELECT MAX(salary)
from "public"."salaries"


-- This is a SQL Comment
/*
* This is a multi-line comment
*/


SELECT COUNT(customerid)
from "public"."customers"
WHERE (state = 'OR' OR state = 'NY') AND gender = 'F';

SELECT count(customerid)
from "public"."customers"
WHERE not age = 55;

--------------

SELECT count(customerid)
from "public"."customers"
WHERE gender = 'F' and state = 'OR';

SELECT count(customerid)
from "public"."customers"
WHERE age > 44 and income >= 100000;

SELECT count(customerid)
from "public"."customers"
WHERE (age > 30 and age < 50) AND income < 50000;

SELECT AVG(income)
from "public"."customers"
WHERE age > 20 and age < 50;

Order of operations
	from -> where -> select

Operator precedence
	Parentheses -> Mult / Div -> Sub / Add -> Not -> And -> Or


---------------------------

SELECT firstname, income, age 
from customers
WHERE income > 50000 AND (age < 30 OR age >= 50)
and (country = 'Japan' OR country = 'Australia')

SELECT SUM(totalamount)
FROM public.orders
WHERE EXTRACT(MONTH FROM orderdate) = 6
  AND EXTRACT(YEAR FROM orderdate) = 2004
  AND totalamount > 100;


----------------------------

SELECT Avg(coalesce(age, 15))
from "Student";

Select coalesce(name, 'The first name has not been given'),
coalesce(lastName, 'The last name has not been given'), age
from "Student"

-----------------------------

SELECT address1, coalesce(address2, 'No 2nd Address')
FROM "public"."customers";

SELECT *
FROM "public"."customers"
WHERE address2 IS NOT null;

SELECT coalesce(lastName, 'Empty'), * 
from "public"."customers"
where age is null;

-----------------------------

SELECT firstname
from "public"."customers"
where (age between 30 and 50) and income < 50000

SELECT avg(income)
from "public"."customers"
where age between 20 and 50

-----------------------------


SELECT count(customerid)
from "public"."orders"
where customerid in (7888, 1082, 12808, 9623)

SELECT count(id)
from "public"."city"
where district in ('Zuid-Holland', 'Noord-Brabant', 'Utrecht')


-----------------------------

ILIKE is case insensitive

SELECT first_name, EXTRACT (YEAR FROM AGE(birth_date)) as "age"
FROM "public"."employees"
where first_name LIKE 'M%';

SELECT count(emp_no)
FROM "public"."employees"
where first_name LIKE 'A%r';

SELECT count(customerid)
from "public"."customers"
where zip::text LIKE '%2%';

SELECT count(customerid)
from "public"."customers"
where zip::text LIKE '2_1%';

SELECT COALESCE(state, 'No state')
from "public"."customers"
where phone::text LIKE '302%';

-----------------------------

Dates are hard because of timezones

UTC - Universal Coordinate Time (standard for time)


SET TIME ZONE 'UTC'

Postgres automatically stores time in utc

ISO8601
YYYY-MM-DDTHH:MM:SS


CREAT TABLE timezones (
	ts 	TIMESTAMP WITHOUT TIME ZONE,
	ts 	TIMESTAMP WITH TIME ZONE,
)

SELECT NOW()::date;
SELECT CURRENT_DATE;

SELECT TO_CHAR( CURRENT_DATE, 'dd/mm/yyyy');

DATE_TRUNC('year', date '1992/11/13'); -> 1992

SELECT emp_no, first_name, last_name,
EXTRACT(YEAR FROM AGE(CURRENT_TIMESTAMP, birth_date)) AS age
FROM "public"."employees"
WHERE EXTRACT(YEAR FROM AGE(birth_date)) > 60;


SELECT Count(emp_no)
FROM "public"."employees"
WHERE EXTRACT(MONTH FROM AGE(hire_date)) = '2';

SELECT Count(emp_no)
FROM "public"."employees"
WHERE EXTRACT(MONTH FROM AGE(birth_date)) = '11';

SELECT Max(EXTRACT(YEAR FROM AGE(birth_date)))
FROM "public"."employees"

SELECT COUNT(orderid)
from "public"."orders"
where EXTRACT(month FROM orderdate) = '1' and EXTRACT(year FROM orderdate) = '2004';

-----------------------------

if you use the following syntax -> DISTINCT salary, from_date

this will return all of the columns with a  distinct pairing of those two things

SELECT distinct title
FROM "public"."titles"

SELECT DISTINCT lifeexpectancy
from "public"."country"
where lifeexpectancy is not null

-----------------------------

SELECT * FORM customers
ORDEF BY name DESC

SELECT * FORM customers
ORDER BY name, lastName DESC

ORDER BY naturally does ASC, in the query above the name is 
ASC and lastName DESC

SELECT * FORM customers
ORDER BY LENGTH(name)

SELECT first_name, last_name
FROM "public"."employees"
order by first_name asc, last_name desc

SELECT first_name, last_name, EXTRACT(YEAR FROM AGE(birth_date)) as age
FROM "public"."employees"
order by EXTRACT(YEAR FROM AGE(birth_date))

SELECT first_name, last_name, hire_date
FROM "public"."employees"
WHERE first_name like 'K%'
order by hire_date;

-----------------------------

MULTI-TABLE SELECT


SELECT a.emp_no,
       CONCAT(a.first_name, a.last_name) as "name",
       b.salary
FROM "public"."employees" as a, "public"."salaries" as b
WHERE a.emp_no = b.emp_no;

Joins from a primary key to a foreign key is the most commen approach



INNER JOIN

these find the intersection of two datasets... where there is overlap

SELECT a.emp_no, b.salary
FROM employees as a, salaries as b
WHERE a.emp_no = b.emp_no;

SELECT a.emp_no, b.salary
FROM employees as a
INNER JOIN salaries as b on b.emp_no = a.emp_no;

These two statements are the same ^^^

the results of a join always come back unsorted so you always need to add an "order by"

SELECT a.emp_no, b.salary
FROM employees as a
INNER JOIN salaries as b on b.emp_no = a.emp_no
ORDER BY a.emp_no;


SELECT a.emp_no,
       CONCAT(a.first_name, ' ', a.last_name) as "name",
       b.salary,
       c.title,
       c.from_date AS "promoted on"
FROM "public"."employees" as a
INNER JOIN "public"."salaries" AS b on a.emp_no = b.emp_no
INNER JOIN "public"."titles" as c ON c.emp_no = a.emp_no 
    AND c.from_date = (b.from_date + interval '2 days')
order by a.emp_no;


SELECT a.emp_no,
       CONCAT(a.first_name, ' ', a.last_name) as "name",
       b.salary,
       c.title,
       c.from_date AS "promoted on"
FROM "public"."employees" as a
INNER JOIN "public"."salaries" AS b on a.emp_no = b.emp_no
INNER JOIN "public"."titles" as c ON c.emp_no = a.emp_no 
    AND (
    b.from_date = c.from_date
    OR c.from_date = (b.from_date + interval '2 days')
    )
order by a.emp_no;


-----------------------------

SELF JOIN

This happens when a table has a foreign key that references its primary key


SELECT a.id, b.name,
FROM employees as a
INNER JOIN employees AS b 
ON a.supervisorid = b.id
order by a.emp_no;

-----------------------------

OUTER JOIN

What if I want the values from one of the tables that doesn't match?


SELECT emp.emp_no
FROM employees AS emp
LEFT JOIN dept_manager AS dep ON emp.emp_no = dep.emp_no
WHERE dep.emp_no IS NULL


-----------------------------

LESS COMMON JOINS

CROSS JOIN
	creates a combination of every row with every other row

	SELECT * FROM "cartesianA"
	CROSS JOIN "cartesianB"

FULL OUTER JOIN
	returns all results from both sets regardless on if they match or not

	
-----------------------------


SELECT e.emp_no, e.first_name, de.dept_no
FROM employees AS e
INNER JOIN dept_emp AS de USING(emp_no)

this works for the standard case of simple joins oof just a pribary key -> foreign key relationship





















































Databases + SQL Fundamentals

SELECT id, firstName
FROM Student;

SELECT *
FROM Student;


Declarative Language is about what will happen
Imperative Language says how it will happen

Heirarchical Database Model
	data is organized in a tree
	this has one-to-many relationship
		this means each parent can have many children,but only one porent

network model
	each child can have multiple parents
	many-to-many relationshups

Relational Model
	using tables instead of parent/child


Codd's 12 rules af Relational Databaso


Tables
	each table has a name
	degree - is the collection of all the columns
	tuple - is a row of data
	cardinality - the collection of rows

Primary and Foreign Keys
	The primary key is teh unique identifier of that data in the table
	the foreign key is a connection to a unique identifier in another table

OLTP vs. OLAP
	OLTP - day to day transaction processes
	OLAP - taking the OLTP and doing analytical processing on that data









History and Story of data

	5 types of databases
		Relational Model Database
		Document Model Database
		Key Value Database
		Graph Model Database
		Wide Columnar Model Database

